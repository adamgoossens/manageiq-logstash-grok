filter {
  if "cloudforms" in [tags] {
    grok {
      patterns_dir => ["/etc/logstash/patterns"]
      # number of metric captures on the queue for a zone
      match => { "message" => "%{MIQ_PREAMBLE}%{NUMBER:miq_capture_count:int} \"%{WORD:miq_capture_type}\"%{GREEDYDATA}\[%{WORD:miq_capture_zone}\]" }
      add_tag => ["miq_capture_healthcheck", "grokked" ]
    }

    # dequeue times for tasks popped off the queue
    if "grokked" not in [tags] {
      grok {
        patterns_dir => ["/etc/logstash/patterns"]
        match => { "message" => "%{MIQ_PREAMBLE}%{GREEDYDATA}Zone: \[%{WORD:miq_message_zone}\], Role: %{NOTSPACE}%{WORD:miq_message_role}?%{NOTSPACE}%{GREEDYDATA}Command: %{NOTSPACE}%{WORD:miq_message_command}%{NOTSPACE}%{GREEDYDATA}Dequeued in: \[%{NUMBER:miq_message_dequeue_in:float}\]%{GREEDYDATA}" }
        add_tag => [ "miq_message", "grokked" ]
      }
    }

    # this message is for EMS refresh timings
    # we do extra grokking for this, returning further events.
    if "grokked" not in [tags] {
      grok {
        patterns_dir => ["/etc/logstash/patterns"]
        # EMS refresh timings
        match => { "message" => "%{MIQ_PREAMBLE}%{GREEDYDATA}EMS: \[%{GREEDYDATA:miq_refresh_ems}\],%{GREEDYDATA}Refreshing targets for EMS...Complete - Timings%{SPACE}{%{GREEDYDATA:miq_refresh_timings}}" }
        add_tag => [ "miq_refresh_timings", "grokked" ]
      }
    }

    # further parse the EMS refresh timings with our ruby script
    if "miq_refresh_timings" in [tags] {
      ruby {
        code => "
          timings = eval('{' + event.get('miq_refresh_timings') + '}')
          timings.each do |k, v|
            event.set('miq_refresh_timing_' + k.to_s, v)
          end
        "
      }
    }

    # catch all for everything else.
    if "grokked" not in [tags] {
      grok {
        patterns_dir => [ "/etc/logstash/patterns" ]
        match => { "message" => "%{MIQ_PREAMBLE}%{GREEDYDATA:miq_msg}" }
        add_tag => [ "grokked" ]
      }
    }

    # cleanup.
    if "grokked" in [tags] {
      mutate {
        remove_field => ["message", "fields", "input_type", "offset", "program"]
        remove_tag => ["beats_input_codec_plain_applied", "_grokparsefailure", "grokked"]
      }
    }
  }
}
